---
sidebar_position: 4
---
import ReactPlayer from 'react-player';

# Publish blog post

Just like before, we need a submission form before publishing a post. To simplify the process, we won't use any text editor here. Instead, we will use a simple textarea for input. You can replace it with any text editor component you prefer.

Create a new page to create a new post and publish it:

```tsx title="/src/pages/post/new.tsx"
import useWallet from '@/hooks/useWallet';
import { signTransaction } from '@/utils/transaction';
import { RPC } from '@ckb-lumos/lumos';
import { createSpore, predefinedSporeConfigs } from '@spore-sdk/core';
import { useRouter } from 'next/router';
import { useState } from 'react';

export default function NewPost() {
  const router = useRouter();
  const { id } = router.query;
  const { address, lock, isConnected, connect } = useWallet();
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');

  const handlePublishPost = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (!address || !lock) return;

    const { txSkeleton } = await createSpore({
      data: {
        content: Buffer.from(JSON.stringify({ title, content })),
        contentType: 'application/json',
        clusterId: id as string,
      },
      fromInfos: [address],
      toLock: lock,
    });
    const tx = await signTransaction(txSkeleton);
    const rpc = new RPC(predefinedSporeConfigs.Aggron4.ckbNodeUrl);
    const hash = await rpc.sendTransaction(tx, 'passthrough');
    setTitle('');
    setContent('');
    console.log(hash);
  };

  return (
    <div>
      {isConnected ? (
        <form onSubmit={handlePublishPost}>
          <div>
            <label htmlFor="title">Title: </label>
            <div>
              <input
                type="text"
                id="title"
                value={title}
                onChange={(e) => setTitle(e.target.value)}
              />
            </div>
          </div>
          <div>
            <label htmlFor="content">Content</label>
            <div>
              <textarea
                id="content"
                value={content}
                onChange={(e) => setContent(e.target.value)}
              />
            </div>
          </div>
          <button type="submit">Publish</button>
        </form>
      ) : (
        <button onClick={() => connect()}>Connect Wallet</button>
      )}
    </div>
  );
}
```

Then let's add a button on the homepage of the site to navigate to this new page for publish post:

```tsx title="/src/page/site/[id].tsx"
export default function SitePage() {
  // ...

  return (
    <div>
      <h1>{siteInfo?.name}</h1>
      <p>{siteInfo?.description}</p>
      {isConnected ? (
				{/* highlight-start */}
        <button onClick={() => router.push(`/post/new?id=${id}`)}>
          Add Post
        </button>
				{/* highlight-end */}
      ) : (
        <button onClick={() => connect()}>Connect Wallet</button>
      )}
      <div></div>
    </div>
  );
}
```

We are taking off at full speed. We have already used `createCluster` in the Spore SDK before, now it's time to use the heavyweight `createSpore`, which is our protagonist. All our blog posts are stored in Spore, fully on the blockchain and immutable.

In the above code, we use `createSpore` to generate transactions for create Spore Cell. It is similar to how we used `createCluster` before but with more content saved in Spore.

There are two fields related to content in Spore: `contentType` and `content`. For our blog posts, we will save the title and content of each post in `content`, using binary format. Then we mark `contentType` as `application/json`, so that when we retrieve the Spore Cell later, we can unpack data and treat it as JSON string. You may notice that with both `contentType` and `content`, any content can be saved, that's how powerful Spore is.

The title and content entered will be saved in Spore using JSON format, and later on, we will parse data from Spore in the same way.

```tsx
{
  "title": "My post",
	"content": "Hello World"
}
```

Another point to note in the `createSpore` data is the `clusterId` field. This field is used to associate Spore with a Cluster. With this field, we can query all Spores associated with a specific clusterId, which means all posts on our site in this tutorial.

After generate the unsigned transaction using `createSpore`, just like before, we call `signTransaction` to request MetaMask for signature. Once signed, it will be sent to the blockchain and wait for confirmation. As mentioned earlier, you will see the transaction hash in the console and can check its status on CKB Explorer.

<ReactPlayer controls url='https://github.com/sporeprotocol/spore-docs/assets/9718515/33b92ce2-00f4-42c0-af0c-cab74a405f2c' />

Here is the transaction  I requested in the video: [https://pudge.explorer.nervos.org/transaction/0x40959ca68f00c3b2e2dfc99344d4be9503e63962885add4d5b15339ca6e825cb](https://pudge.explorer.nervos.org/transaction/0x40959ca68f00c3b2e2dfc99344d4be9503e63962885add4d5b15339ca6e825cb)

## Show all blog posts

We have published a new blog post, and now we need to query them from the blockchain and display them on the page. Obviously, you may already know how to do it. Following the implementation of displaying all site lists, we can easily achieve it.

Add some code in `src/pages/site/[id].tsx` to display all posts:

```tsx title="/src/pages/site/[id].tsx"
import useWallet from '@/hooks/useWallet';
import { Indexer } from '@ckb-lumos/lumos';
import {
  predefinedSporeConfigs,
  unpackToRawClusterData,
  unpackToRawSporeData,
} from '@spore-sdk/core';
import { useRouter } from 'next/router';
import { useEffect, useState } from 'react';
import { Site } from '..';
// highlight-start
import Link from 'next/link';

export type Post = {
  id: string;
  title: string;
  content: string;
};
// highlight-end

export default function SitePage() {
  const router = useRouter();
  const { id } = router.query;
  const { lock, isConnected, connect } = useWallet();
  const [siteInfo, setSiteInfo] = useState<Site>();
	// highlight-next-line
  const [posts, setPosts] = useState<Post[]>([]);

  useEffect(() => {
    if (!id) {
      return;
    }

    (async () => {
      const indexer = new Indexer(predefinedSporeConfigs.Aggron4.ckbIndexerUrl);
      const { script } = predefinedSporeConfigs.Aggron4.scripts.Cluster;
      const collector = indexer.collector({
        type: { ...script, args: id as string },
      });

      for await (const cell of collector.collect()) {
        const unpacked = unpackToRawClusterData(cell.data);
        setSiteInfo({
          id: cell.cellOutput.type!.args,
          name: unpacked.name,
          description: unpacked.description,
        });
      }
    })();

		// highlight-start
    (async () => {
      const indexer = new Indexer(predefinedSporeConfigs.Aggron4.ckbIndexerUrl);
      const { script } = predefinedSporeConfigs.Aggron4.scripts.Spore;
      const collector = indexer.collector({
        type: { ...script, args: '0x' },
        lock,
      });

      const posts = [];
      for await (const cell of collector.collect()) {
        const unpacked = unpackToRawSporeData(cell.data);
        const { contentType } = unpacked;

        if (contentType !== 'application/json' || unpacked.clusterId !== id) {
          continue;
        }

        const { title, content } =
          JSON.parse(bufferToRawString(unpacked.content)) ?? {};
        if (title && content) {
          posts.push({
            id: cell.cellOutput.type!.args,
            title,
            content,
          });
        }
      }
      setPosts(posts);
    })();
		// highlight-end
  }, [id, lock]);

  // ...
}
```

After loading on the homepage of the site, we use Indexer to retrieve all Spore Cells that belong to you from the blockchain. Then we filter them based on `contentType` and `clusterId`, ensuring that we get only the blog posts for this current site that we want. Then as mentioned before, we unpack the data and parse it using JSON string format, and finally save it in the `posts` state.

After obtaining and saving the post data, we need to display it on the page:

```tsx title="/src/pages/site/[id].tsx"
export default function SitePage() {
  // ...

  return (
    <div>
      <h1>{siteInfo?.name}</h1>
      <p>{siteInfo?.description}</p>
      {isConnected ? (
        <button onClick={() => router.push(`/post/new?id=${id}`)}>
          Add Post
        </button>
      ) : (
        <button onClick={() => connect()}>Connect Wallet</button>
      )}
			{/* highlight-start */}
      <div>
        <h2>Posts</h2>
        <ul>
          {posts.map((post) => (
            <li key={post.id}>
              <Link href={`/post/${post.id}`}>{post.title}</Link>
            </li>
          ))}
        </ul>
      </div>
			{/* highlight-end */}
    </div>
  );
}
```

![](https://github.com/sporeprotocol/spore-docs/assets/9718515/226de0c2-5a73-494c-9245-23f98e2a3498)

## Display blog post

We are almost done, now we just need to display the blog post data saved in Spore. We add a new page in our project to display the blog post:

```tsx title="/src/pages/post/[id].tsx"
import { Indexer } from '@ckb-lumos/lumos';
import {
  SporeData,
  bufferToRawString,
  predefinedSporeConfigs,
} from '@spore-sdk/core';
import { useRouter } from 'next/router';
import { useEffect, useState } from 'react';
import { useRemark } from 'react-remark';
import { Post } from '../site/[id]';

export default function Post() {
  const router = useRouter();
  const { id } = router.query;
  const [post, setPost] = useState<Post>();
  const [reactContent, setMarkdownSource] = useRemark();

  useEffect(() => {
    if (!id) {
      return;
    }

    (async () => {
      const indexer = new Indexer(predefinedSporeConfigs.Aggron4.ckbIndexerUrl);
      const { script } = predefinedSporeConfigs.Aggron4.scripts.Spore;
      const collector = indexer.collector({
        type: { ...script, args: id as string },
      });

      for await (const cell of collector.collect()) {
        const unpacked = SporeData.unpack(cell.data);

        const { title, content } =
          JSON.parse(bufferToRawString(unpacked.content)) ?? {};
        if (title && content) {
          setPost({
            id: cell.cellOutput.type!.args,
						outPoint: cell.outPoint!,
            title,
            content,
          });
          return;
        }
      }
    })();
  }, [id]);

  useEffect(() => {
    setMarkdownSource(post?.content ?? '');
  }, [post, setMarkdownSource]);

  return (
    <div>
      <h1>{post?.title}</h1>
      <div style={{ width: '600px' }}>{reactContent}</div>
    </div>
  );
}
```

The steps are similar to before. We use the spore id passed in from the page route as a query condition, combined with Spore Type Script, we can query the specific Spore Cell we need. Then unpack & JSON parse, and after obtaining our data, display it. By now, we have repeated this process several times already. I believe you already know how to retrieve the desired data on Nervos CKB.

While writing this part of the code, I thought about putting The Nervos CKB Whitepaper on the blockchain. Therefore, I used `react-remark` to render Markdown content here. If you don't need it, you can ignore this part. You can see an example at [The Nervos Network Positioning Paper - Spore Blog Tutorial](https://spore-blog-tutorial.vercel.app/post/0x40a190ca8f5c64c66381e87769f5816a624c4f7868dc2c5246584dbb9574b20a), and this post was developed and published following the steps in this tutorial.

Now let's take a look at the blog post we just created with only "Hello World" content.

<ReactPlayer controls url='https://github.com/sporeprotocol/spore-docs/assets/9718515/2078678a-b732-495a-9cac-26077fb632e8' />

## Delete post

With the publication of posts, there naturally needs to be a function to delete posts. Due to the immutable nature of Spore, modifying the content of an post can only be achieved by delete and republish.

This may sound ordinary and not very exciting. However, on Nervos CKB, things are different from other blockchain-based blogging platforms like Mirror or xLog. When publishing content on these platforms, the fees paid during transactions disappear. But on CKB, storage space equals value. Therefore, when you publish a blog post, the amount of storage space you occupy corresponds to the number of CKB tokens being used. Only a small amount of CKB is used for transaction fees. And when you delete this blog post, those occupied CKB tokens are unlocked again and can be used once more. This encourages everyone to store valuable content on the blockchain. Exciting, isn't it?

Alright then! Let's add the delete functionality and retrieve your CKB tokens back. We simply add their respective delete buttons after each post in the list on our site's homepage:

```tsx title="/src/pages/site/[id].tsx"
export default function SitePage() {
	// ...

  return (
    <div>
      <h1>{siteInfo?.name}</h1>
      <p>{siteInfo?.description}</p>
      {isConnected ? (
        <button onClick={() => router.push(`/post/new?id=${id}`)}>
          Add Post
        </button>
      ) : (
        <button onClick={() => connect()}>Connect Wallet</button>
      )}
      <div>
        <h2>Posts</h2>
				{/* highlight-start */}
        <ul>
          {posts.map((post) => (
            <li key={post.id}>
              <Link href={`/post/${post.id}`}>{post.title}</Link>
              {isConnected && (
                <button onClick={() => handlePostDelete(post.id)}>
                  delete
                </button>
              )}
            </li>
          ))}
        </ul>
				{/* highlight-end */}
      </div>
    </div>
  );
}
```

Now let's implement the logic for when a delete button is clicked; it's similar to what we did when creating posts before but this time we will use `destroySpore`, which is provided by Spore SDK:

```tsx title="/src/pages/site/[id].tsx"
import useWallet from '@/hooks/useWallet';
import { Indexer, OutPoint, RPC } from '@ckb-lumos/lumos';
import {
  bufferToRawString,
  destroySpore,
  predefinedSporeConfigs,
  unpackToRawClusterData,
  unpackToRawSporeData,
} from '@spore-sdk/core';
import { useRouter } from 'next/router';
import { useCallback, useEffect, useState } from 'react';
import { Site } from '..';
import Link from 'next/link';
import { signTransaction } from '@/utils/transaction';

export type Post = {
  id: string;
  title: string;
  content: string;
	// highlight-next-line
  outPoint: OutPoint;
};

export default function SitePage() {
  const router = useRouter();
  const { id } = router.query;
  const { lock, isConnected, connect } = useWallet();
  const [siteInfo, setSiteInfo] = useState<Site>();
  const [posts, setPosts] = useState<Post[]>([]);
  const { address } = useWallet();

	// highlight-start
  const fetchPosts = useCallback(async () => {
    const indexer = new Indexer(predefinedSporeConfigs.Aggron4.ckbIndexerUrl);
    const { script } = predefinedSporeConfigs.Aggron4.scripts.Spore;
    const collector = indexer.collector({
      type: { ...script, args: '0x' },
      lock,
    });

    const posts = [];
    for await (const cell of collector.collect()) {
      const unpacked = unpackToRawSporeData(cell.data);
      const { contentType } = unpacked;

      if (contentType !== 'application/json' || unpacked.clusterId !== id) {
        continue;
      }

      const { title, content } =
        JSON.parse(bufferToRawString(unpacked.content)) ?? {};
      if (title && content) {
        posts.push({
          id: cell.cellOutput.type!.args,
          title,
          content,
          outPoint: cell.outPoint!,
        });
      }
    }
    setPosts(posts);
  }, [id, lock]);
	// highlight-end

  useEffect(() => {
    if (!id) {
      return;
    }

    (async () => {
      const indexer = new Indexer(predefinedSporeConfigs.Aggron4.ckbIndexerUrl);
      const { script } = predefinedSporeConfigs.Aggron4.scripts.Cluster;
      const collector = indexer.collector({
        type: { ...script, args: id as string },
      });

      for await (const cell of collector.collect()) {
        const unpacked = unpackToRawClusterData(cell.data);
        setSiteInfo({
          id: cell.cellOutput.type!.args,
          name: unpacked.name,
          description: unpacked.description,
        });
      }
    })();
		// highlight-next-line
    fetchPosts();
  }, [id, lock, fetchPosts]);

	// highlight-start
  const handlePostDelete = async (id: string) => {
    if (!address) return;

    const post = posts.find((post) => post.id === id);
    if (!post) return;

    const { txSkeleton } = await destroySpore({
      outPoint: post.outPoint,
      fromInfos: [address],
    });
    const tx = await signTransaction(txSkeleton);
    const rpc = new RPC(predefinedSporeConfigs.Aggron4.ckbNodeUrl);
    const hash = await rpc.sendTransaction(tx, 'passthrough');
    setTimeout(() => fetchPosts(), 1000);
    console.log(hash);
  };
	// highlight-end

  return ...
}
```

It looks similar to before, the only thing we need to pay attention to is the `outPoint` field. We just need to pass the outPoint of the Spore Cell obtained from query the blog post list earlier. The rest of the transaction-related steps are exactly the same as before.

That's it! We have implemented the functionality to delete blog posts. If you observe closely, you will notice that your CKB balance increases after an post is deleted!


<ReactPlayer controls url='https://github.com/sporeprotocol/spore-docs/assets/9718515/47eda882-cb8f-478a-b54b-c1400be35279' />

<ReactPlayer controls url='https://github.com/sporeprotocol/spore-docs/assets/9718515/00717f4f-d1fe-4f5f-b7d1-e137805d9d5a' />

:::tip
You can check out the publish-post branch on the associated code repository to view all the code for this stage: `git checkout 03-publish-post`
:::

