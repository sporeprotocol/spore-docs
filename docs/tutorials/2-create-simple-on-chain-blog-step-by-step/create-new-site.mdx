---
sidebar_position: 3
---
import ReactPlayer from 'react-player';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Stage 2: Create Blog Site

In this stage, we will dive into the practical steps of using the Spore Protocol to create an on-chain blog. 

:::tip
ðŸ‘‰ You can explore the [`02-create-site`](https://github.com/sporeprotocol/spore-blog-tutorial/tree/02-create-site/src) branch in the repository using the command `git checkout 02-create-site` to view all the code for this stage.
:::

### **Concepts to Know**

Before we get into the practical steps, it's essential to grasp two key concepts in the Spore Protocol:

1. **Spore**: Spore is a fundamental component used for storing data on the blockchain. In our blog, we'll use Spore to store the actual blog posts.
2. **Cluster**: A Cluster is a collection of Spores. In our case, it will represent our entire blog site.

## Step 1: Set up

**You Need:**

- Files: **`src/pages/index.tsx`** and `**src/hooks/useWallet.ts**`

** 1. Create `src/hooks/useWallet.ts`**

To prepare for future pages on our blog site, we need to segregate the logic for connecting the wallet into a separate file called `useWallet.ts` from the `index.tsx` file. This change is essential because we haven't persisted the connection state. Here's the code for `src/hooks/useWallet.ts`:

```tsx title="/src/hooks/useWallet.ts"
import { BI, commons, config, helpers } from '@ckb-lumos/lumos';
import { useEffect, useMemo, useState } from 'react';
import { useAccount, useConnect, useDisconnect } from 'wagmi';
import { InjectedConnector } from 'wagmi/connectors/injected';
import { getCapacities } from '@/utils/balance';

export default function useWallet() {
  const { address: ethAddress, isConnected } = useAccount();
  const { connect } = useConnect({
    connector: new InjectedConnector(),
  });
  const { disconnect } = useDisconnect();
  const [balance, setBalance] = useState<BI | null>(null);

  const lock = useMemo(() => {
    if (!ethAddress) return;

    return commons.omnilock.createOmnilockScript(
      {
        auth: { flag: 'ETHEREUM', content: ethAddress ?? '0x' },
      },
      { config: config.predefined.AGGRON4 },
    );
  }, [ethAddress]);

  const address = useMemo(
    () =>
      lock
        ? helpers.encodeToAddress(lock, {
            config: config.predefined.AGGRON4,
          })
        : undefined,
    [lock],
  );

  useEffect(() => {
    if (!address) {
      return;
    }
    getCapacities(address).then((capacities) => {
      setBalance(capacities.div(10 ** 8));
    });
  }, [address]);

  return {
    address,
    lock,
    balance,
    isConnected,
    connect,
    disconnect,
  };
}
```

** 2. Import the `useWallet` module**

In `src/pages/index.tsx`, include the following statement

```tsx title="/src/pages/index.tsx"
import useWallet from '@/hooks/useWallet';
```

Remove any unnecessary imports, and then replace the relevant parts with the following:

```tsx title="/src/pages/index.tsx"
export default function Home() {
	// highlight-start
  const { address, lock, balance, isConnected, connect, disconnect } =
    useWallet();
	// highlight-end

```




---

Let's start with the simplest part. When creating a site, we need a form to input the site name and description, and we need a button to request the transaction for creating the site (i.e., creating a Spore Cluster). We add the following code in `src/pages/index.ts`:

```tsx title="/src/pages/index.tsx"
import { useAccount, useConnect, useDisconnect } from 'wagmi';
import { InjectedConnector } from 'wagmi/connectors/injected';
import { BI, commons, config, helpers } from '@ckb-lumos/lumos';
import { useEffect, useMemo, useState } from 'react';
import { getCapacities } from '../utils/balance';

export default function Home() {
  const { address: ethAddress, isConnected } = useAccount();
  const { connect } = useConnect({
    connector: new InjectedConnector(),
  });
  const { disconnect } = useDisconnect();
  const [balance, setBalance] = useState<BI | null>(null);
	// highlight-start
  const [siteName, setSiteName] = useState('');
  const [siteDescription, setSiteDescription] = useState('');
	// highlight-end

	// ...

	// highlight-start
  const handleCreateSite = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    console.log(siteName, siteDescription);
  };

  if (!isConnected) {
    return <button onClick={() => connect()}>Connect Wallet</button>;
  }

  return (
    <div>
      <div>
        <div>CKB Address: {address}</div>
        <div>Balance: {balance?.toNumber() ?? 0} CKB</div>
        <button onClick={() => disconnect()}>Disconnect</button>
      </div>
      <div>
        <h2>Create Site</h2>
        <form onSubmit={handleCreateSite}>
          <div>
            <label htmlFor="name">Name: </label>
            <input
              type="text"
              id="name"
              value={siteName}
              onChange={(e) => setSiteName(e.target.value)}
            />
          </div>
          <div>
            <label htmlFor="description">Description: </label>
            <input
              type="text"
              id="description"
              value={siteDescription}
              onChange={(e) => setSiteDescription(e.target.value)}
            />
          </div>
          <button type="submit">Create</button>
        </form>
      </div>
    </div>
  );
	// highlight-end
}
```

Now we have a simple form that, when the "Create" button is clicked, will get the values of `name` and `description`.

## Request transaction

Now let's generate our first transaction using the [Spore SDK](https://github.com/sporeprotocol/spore-sdk), which is a TypeScript SDK for the Spore Protocol. It provides methods to simplify the process of generating transactions. First, we need to install the SDK in our project:

```bash
npm install @spore-sdk/core --save
```

Since we want to create a cluster to represent our site, we will use the `createCluster` method. We add the following code in the `handleCreateSite` function in `src/pages/index.tsx`:

```tsx title="/src/pages/index.tsx"
import { useAccount, useConnect, useDisconnect } from 'wagmi';
import { InjectedConnector } from 'wagmi/connectors/injected';
// highlight-next-line
import { BI, RPC, commons, config, helpers } from '@ckb-lumos/lumos';
import { useEffect, useMemo, useState } from 'react';
import { getCapacities } from '../utils/balance';
// highlight-next-line
import { createCluster, predefinedSporeConfigs } from '@spore-sdk/core';

export default function Home() {
  // ...

	// highlight-start
  const lock = useMemo(() => {
    if (!ethAddress) return;
    const lock = commons.omnilock.createOmnilockScript(
      {
        auth: { flag: 'ETHEREUM', content: ethAddress ?? '0x' },
      },
      { config: config.predefined.AGGRON4 },
    );
    return lock;
  }, [ethAddress]);

  const address = useMemo(() => {
    if (!lock) return;
    return helpers.encodeToAddress(lock, { config: config.predefined.AGGRON4 });
  }, [lock]);
	// highlight-end

  useEffect(() => {
    if (!address) {
      return;
    }
    getCapacities(address).then((capacities) => {
      setBalance(capacities.div(10 ** 8));
    });
  }, [address]);

	// highlight-start
  const handleCreateSite = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (!address || !lock) return;

    const { txSkeleton } = await createCluster({
      data: {
        name: siteName,
        description: siteDescription,
      },
      fromInfos: [address],
      toLock: lock,
    });
    const tx = await signTransaction(txSkeleton); // <- Not implemented yet, so the code will throw an error.
    const rpc = new RPC(predefinedSporeConfigs.Aggron4.ckbNodeUrl);
    const hash = await rpc.sendTransaction(tx, 'passthrough');
    console.log(hash);
  };
	// highlight-end

  if (!isConnected) {
    return <button onClick={() => connect()}>Connect Wallet</button>;
  }

  return (
    <div>
     // ...
    </div>
  );
}
```

Let's explain the purpose of this code step by step:

- First, we use `createCluster` to generate the transaction for creating the cluster. The parameters include the `name` and `description` fields from the form we created earlier. These are the field names for the data that can be stored in the Spore Cluster Cell, so we pass them directly. `fromInfos` indicates from where the transactionâ€™s sponsors specifies to collect capacity, i.e., who will pay the transaction capacity & fee. `toLock` indicates who owns the final created Spore Cluster Cell. In our tutorial, both of these are ourselves, so we fill in our lock and address.
- Next, we call `signTransaction` to sign the transaction. Specifically, the page will use MetaMask to sign the transaction. We haven't implemented this yet, but we will do so later.
- Finally, we send the signed transaction to the blockchain using the RPC of the Nervos CKB testnet. After `rpc.sendTransaction` is called, it will return a transaction hash. However, this does not mean that the transaction is confirmed. We still need to wait for the block on the blockchain to be mined and confirmed for the transaction to be considered successful.

So good so far, let's implement `signTransaction`. Create the `src/utils/transaction.ts` file and add the following code:

```tsx title="/src/utils/transaction.ts"
import { commons, config, helpers } from '@ckb-lumos/lumos';
import { blockchain } from '@ckb-lumos/base';
import { bytes } from '@ckb-lumos/codec';
import { signMessage } from 'wagmi/actions';

export async function signTransaction(
  txSkeleton: helpers.TransactionSkeletonType,
) {
  config.initializeConfig(config.predefined.AGGRON4);
  let tx = commons.omnilock.prepareSigningEntries(txSkeleton);

  const signedWitnesses = new Map<string, string>();
  const signingEntries = tx.get('signingEntries')!;
  for (let i = 0; i < signingEntries.size; i += 1) {
    const entry = signingEntries.get(i)!;
    if (entry.type === 'witness_args_lock') {
      const { message, index } = entry;
      if (signedWitnesses.has(message)) {
        const signedWitness = signedWitnesses.get(message)!;
        tx = tx.update('witnesses', (witnesses) => {
          return witnesses.set(index, signedWitness);
        });
        continue;
      }

      let signature = await signMessage({ message: { raw: message } as any });

      // Fix ECDSA recoveryId v parameter
      // <https://bitcoin.stackexchange.com/questions/38351/ecdsa-v-r-s-what-is-v>
      let v = Number.parseInt(signature.slice(-2), 16);
      if (v >= 27) v -= 27;
      signature = ('0x' +
        signature.slice(2, -2) +
        v.toString(16).padStart(2, '0')) as `0x${string}`;

      const signedWitness = bytes.hexify(
        blockchain.WitnessArgs.pack({
          lock: commons.omnilock.OmnilockWitnessLock.pack({
            signature: bytes.bytify(signature!).buffer,
          }),
        }),
      );
      signedWitnesses.set(message, signedWitness);

      tx = tx.update('witnesses', (witnesses) => {
        return witnesses.set(index, signedWitness);
      });
    }
  }

  const signedTx = helpers.createTransactionFromSkeleton(tx);
  return signedTx;
}

```

This implementation may be a bit complex and requires some background knowledge of Nervos CKB to understand. If you are not familiar with it, you can simply copy and use this code.

In summary, the `signTransaction` function roughly follows this logic: First, we need to get the `signingEntries` from the passed `txSkeleton` and use MetaMask to sign the messages within. After signing, we need to perform some processing (mainly to handle the ECDSA recoveryID v parameter) and use the methods provided by @ckb-lumos/lumos to pack the signature into the witness corresponding to Omnilock. We then fill it back into the `txSkeleton` and generate the signed transaction for sending to the Nervos CKB.

```tsx title="/src/pages/index.tsx"
// highlight-next-line
import { signTransaction } from '@/utils/transaction';

// ...
```

After adding the implementation of `signTransaction`, we can create our site. After confirming the MetaMask signature request, you can see the transaction hash in the console of the DevTools. You can copy it and query it on [CKB Explorer](https://pudge.explorer.nervos.org/). For example, you can see my transaction for creating a website: [https://pudge.explorer.nervos.org/transaction/0xc2c2ea9d99a2f2819efd95cdace0672817474d51881ca0edbc66cbb5eaa0cbae](https://pudge.explorer.nervos.org/transaction/0xc2c2ea9d99a2f2819efd95cdace0672817474d51881ca0edbc66cbb5eaa0cbae)

<ReactPlayer controls url='https://github.com/sporeprotocol/spore-docs/assets/9718515/8db0a31a-a3ae-4d79-9f25-56a7a08ef42f' />

## Display all sites

After creating the site, we cannot see it yet. At this stage, we can only see the Spore Cluster Cell in CKB Explorer. Now let's add some code to display it on the page. Add the following code in `src/pages/index.tsx`:

```tsx title="/src/pages/index.tsx"
import { useAccount, useConnect, useDisconnect } from 'wagmi';
import { InjectedConnector } from 'wagmi/connectors/injected';
// highlight-next-line
import { BI, Indexer, RPC, commons, config, helpers } from '@ckb-lumos/lumos';
import { useEffect, useMemo, useState } from 'react';
import { getCapacities } from '../utils/balance';
// highlight-start
import {
  createCluster,
  predefinedSporeConfigs,
  unpackToRawClusterData,
} from '@spore-sdk/core';
// highlight-end
import { signTransaction } from '@/utils/transaction';

// highlight-start
export type Site = {
  id: string;
  name: string;
  description: string;
};
// highlight-end

export default function Home() {
  // ...

	// highlight-next-line
  const [sites, setSites] = useState<Site[]>([]);

  // ...

	// highlight-start
  useEffect(() => {
    if (!lock) {
      return;
    }

    (async () => {
      const indexer = new Indexer(predefinedSporeConfigs.Aggron4.ckbIndexerUrl);
      const { script } = predefinedSporeConfigs.Aggron4.scripts.Cluster;
      const collector = indexer.collector({
        type: { ...script, args: '0x' },
        lock,
      });

      const sites = [];
      for await (const cell of collector.collect()) {
        const unpacked = unpackToRawClusterData(cell.data);
        sites.push({
          id: cell.cellOutput.type!.args,
          name: unpacked.name,
          description: unpacked.description,
        });
      }
      setSites(sites);
    })();
  }, [lock]);
	// highlight-end

  // ...
}
```

The logic here is simple and similar to getting the capacities of the  CKB address earlier. The difference is that besides passing lock into `indexer.collector`, we also pass in Type Script corresponding to Spore Cluster, which means we are querying for cells with Type Script type as Spore Cluster and belong to us. After obtaining these Spore Cluster Cells, we need to use `unpackToRawClusterData` provided by Spore SDK to get the data from the cell. After collecting the data from the Indexer, we save it in the `sites` state.

Then we display them:

```tsx title="/src/pages/index.tsx"
return (
    <div>
      <div>
        <div>CKB Address: {address}</div>
        <div>Balance: {balance?.toNumber() ?? 0} CKB</div>
        <button onClick={() => disconnect()}>Disconnect</button>
      </div>
      <div>
        <h2>Create Site</h2>
        <form onSubmit={handleCreateSite}>
          <div>
            <label htmlFor="name">Name: </label>
            <input
              type="text"
              id="name"
              value={siteName}
              onChange={(e) => setSiteName(e.target.value)}
            />
          </div>
          <div>
            <label htmlFor="description">Description: </label>
            <input
              type="text"
              id="description"
              value={siteDescription}
              onChange={(e) => setSiteDescription(e.target.value)}
            />
          </div>
          <button type="submit">Create</button>
        </form>
      </div>
			{/* highlight-start */}
      <div>
        <h2>My Sites</h2>
        <ul>
          {sites.map((site) => (
            <li key={site.id}>{site.name}</li>
          ))}
        </ul>
      </div>
			{/* highlight-end */}
    </div>
  );
```

This way, we have obtained the Spore Cluster that we just created from the blockchain, which is our site.

<ReactPlayer controls url='https://github.com/sporeprotocol/spore-docs/assets/9718515/f53b4633-4fb4-4b64-bbea-2d369b711f2e' />

## Add site homepage

Okay, next we need to add a new page as the homepage of the site. Although we don't have any blog posts now, we need to have a site homepage and then add the functionality to publish post on top of it, and the published posts will be displayed on the site homepage.

Since there will be a new page, we need to add a copy of the logic for connecting wallet to the new page because we haven't persisted the connect state. Here we extract the logic for connecting wallet into `src/hooks/useWallet.ts` file:

```tsx title="/src/hooks/useWallet.ts"
import { BI, commons, config, helpers } from '@ckb-lumos/lumos';
import { useEffect, useMemo, useState } from 'react';
import { useAccount, useConnect, useDisconnect } from 'wagmi';
import { InjectedConnector } from 'wagmi/connectors/injected';
import { getCapacities } from '@/utils/balance';

export default function useWallet() {
  const { address: ethAddress, isConnected } = useAccount();
  const { connect } = useConnect({
    connector: new InjectedConnector(),
  });
  const { disconnect } = useDisconnect();
  const [balance, setBalance] = useState<BI | null>(null);

  const lock = useMemo(() => {
    if (!ethAddress) return;

    return commons.omnilock.createOmnilockScript(
      {
        auth: { flag: 'ETHEREUM', content: ethAddress ?? '0x' },
      },
      { config: config.predefined.AGGRON4 },
    );
  }, [ethAddress]);

  const address = useMemo(
    () =>
      lock
        ? helpers.encodeToAddress(lock, {
            config: config.predefined.AGGRON4,
          })
        : undefined,
    [lock],
  );

  useEffect(() => {
    if (!address) {
      return;
    }
    getCapacities(address).then((capacities) => {
      setBalance(capacities.div(10 ** 8));
    });
  }, [address]);

  return {
    address,
    lock,
    balance,
    isConnected,
    connect,
    disconnect,
  };
}
```

We have already explained the part about connecting to the wallet before, so we won't go into it again here. I suggest you directly copy this code into your project because it is not the focus of this tutorial.

At the same time, we delete unnecessary imports and replace the relevant parts :

```tsx title="/src/pages/index.tsx"
// highlight-start
import { Indexer, RPC } from '@ckb-lumos/lumos';
import { useEffect, useState } from 'react';
// highlight-end
import {
  createCluster,
  predefinedSporeConfigs,
  unpackToRawClusterData,
} from '@spore-sdk/core';
import { signTransaction } from '@/utils/transaction';
import useWallet from '@/hooks/useWallet';

type Site = {
  id: string;
  name: string;
  description: string;
};

export default function Home() {
	// highlight-next-line
  const { address, lock, balance, isConnected, connect, disconnect } =
    useWallet();
  const [siteName, setSiteName] = useState('');
  const [siteDescription, setSiteDescription] = useState('');
  const [sites, setSites] = useState<Site[]>([]);

  // ...
}
```

Then we add a new page `src/pages/site/[id].tsx`:

```tsx title="/src/pages/site/[id].tsx"
import useWallet from '@/hooks/useWallet';
import { Indexer } from '@ckb-lumos/lumos';
import { predefinedSporeConfigs, unpackToRawClusterData } from '@spore-sdk/core';
import { useRouter } from 'next/router';
import { useEffect, useState } from 'react';
import { Site } from '..';

export default function SitePage() {
  const router = useRouter();
  const { id } = router.query;
  const { lock, isConnected, connect } = useWallet();
  const [siteInfo, setSiteInfo] = useState<Site>();

  useEffect(() => {
    if (!id) {
      return;
    }

    (async () => {
      const indexer = new Indexer(predefinedSporeConfigs.Aggron4.ckbIndexerUrl);
      const { script } = predefinedSporeConfigs.Aggron4.scripts.Cluster;
      const collector = indexer.collector({
        type: { ...script, args: id as string },
      });

      for await (const cell of collector.collect()) {
        const unpacked = unpackToRawClusterData(cell.data);
        setSiteInfo({
          id: cell.cellOutput.type!.args,
          name: unpacked.name,
          description: unpack.description,
        });
      }
    })();
  }, [id, lock]);

  return (
    <div>
      <h1>{siteInfo?.name}</h1>
      <p>{siteInfo?.description}</p>
      {isConnected ? (
        <button>Add Post</button>
      ) : (
        <button onClick={() => connect()}>Connect Wallet</button>
      )}
      <div></div>
    </div>
  );
}
```

As shown above, the logic here for fetch all site information is not much different from before. The only difference is that we get the id parameter (which is the cluster id) from the router to use as a query parameter in `indexer.collector`. We query type for Spore Cluster and args for the current id of Spore Cluster Cell. After that, we unpack it and save it to `siteInfo` and display it on the page.

Oh, by the way, don't forget to add links on all previous sites that redirect to this new site's homepage:

```tsx title="/src/pages/index.tsx"
export default function Home() {
	// ...

  return (
    <div>
      {/* ... */}
      <div>
        <h2>My Sites</h2>
        <ul>
          {sites.map((site) => (
            <li key={site.id}>
							{/* highlight-start */}
              <Link href={`/site/${site.id}`}>{site.name}</Link>
							{/* highlight-end */}
            </li>
          ))}
        </ul>
      </div>
    </div>
  );
}
```

Now we can jump to the homepage in the list of all sites. Although there is currently only the name and description, don't worry, everything will be added soon.

<ReactPlayer controls url='https://github.com/sporeprotocol/spore-docs/assets/9718515/a1e7cc83-40d9-4b5f-afca-6b912ac73d6f' />

:::tip
You can check out the create-site branch on the associated code repository to view all the code for this stage: `git checkout 02-create-site`
:::

